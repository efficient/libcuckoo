public:

	//===================================================================
	//  Light Transaction chart
	//      If exists
	//			call exists_function (check/update/delete possible only)
	//		else (not exists)
	//			call not_exists_function (insert possible only)
	//
	//   Level 1: single operation 
	//				find/find_fn (only valid value returns) ;
	//				update/update_fn (complex update);
	//				erase/erase-fn (conditional erase);
	//
	//	 Level 2: fixed combinations
	//			 exists_function (check/update, delete) + not_exists_function (insert) 
	//			upsert=check/update + insert (exists already) 
	//			find_insert=find+ insert
	//			upsert_fn=check/update_fn+insert_fn
	//			delete_insert= delete + insert (wired)
	//	
	//	Level 3: Flexible Combinations
	//		such as Find_or_Delete
	//	
	//	Level 4: Flexible Combinations
	//		to make basic operations are public. And programmer can make flexible logical
	//			
	//===================================================================

	// Checker is an Updater with a bool as return value
	//! For any update operations, the callable passed in must be convertible to
	//! the following type
	typedef std::function<bool(mapped_type&)> checker_type;

	// Getter is an function to return a mapped_type, which is used in insert operation
	//! For any get operations, the callable passed in must be convertible to
	//! the following type

	typedef std::function<mapped_type()> getter_type;

	//
	// try_check_bucket_fn will search the bucket for the given key and check
	// its associated value with the given condition function if it finds it.

	// LY: this function is derived from try_update_bucket_fn.
	// The difference is that in try_check_bucket_fn uses return value of Checker.

	template <typename K, typename Checker>
	bool try_check_bucket_fn(const partial_t partial, const K &key,
		Checker fn, Bucket& b) {
		// Silence a warning from MSVC about partial being unused if is_simple.
		(void)partial;
		for (size_t i = 0; i < slot_per_bucket; ++i) {
			if (!b.occupied(i)) {
				continue;
			}
			if (!is_simple && b.partial(i) != partial) {
				continue;
			}
			if (key_eq()(b.key(i), key)) {
				return fn(b.val(i));
				//return true;
			}
		}
		return false;
	}

	// cuckoo_check_fn searches the table for the given key and runs the check
	// function on its value if it finds it, assigning the check result of the
	// function to the value. It expects the locks to be taken and released
	// outside the function.

	//LY: cuckoo_check_fn is derived from cuckoo_update_fn
	template <typename K, typename Checker>
	cuckoo_status cuckoo_check_fn(const K &key, Checker fn,
		const size_t hv, const size_t i1,
		const size_t i2) {
		const partial_t partial = partial_key(hv);
		if (try_check_bucket_fn(partial, key, fn, buckets_[i1])) {
			return ok;
		}
		if (try_check_bucket_fn(partial, key, fn, buckets_[i2])) {
			return ok;
		}
		return failure_key_not_found;
	}

	//! erase_fn checks the value associated with \p key with the function \p
	//! fn. \p fn will be passed one argument of type \p mapped_type& and can
	//! modify the argument as desired, returning a bool value. If it returns true,
	// the Key-Value should be erased.

	//LY: this function is derived from update_fn and also erase.
	template <typename K, typename Checker>
	typename std::enable_if<
		std::is_convertible<Checker, checker_type>::value,
		bool>::type erase_fn(const K& key, Checker fn) {
		size_t hv = hashed_key(key);
		auto b = snapshot_and_lock_two(hv);
		const cuckoo_status st = cuckoo_check_fn(key, fn, hv, b.i[0], b.i[1]);

		if (st == ok)
			return	(cuckoo_delete(key, hv, b.i[0], b.i[1]) == ok);
		else
			return false;
	}

	// try_read_from_bucket_fn will search the bucket for the given key and store
	// the associated value if it finds it.
	template <typename K, typename Checker>
	bool try_read_from_bucket_fn(const partial_t partial, const K &key,
		mapped_type &val, Checker fn, const Bucket& b) {
		// Silence a warning from MSVC about partial being unused if is_simple.
		(void)partial;
		for (size_t i = 0; i < slot_per_bucket; ++i) {
			if (!b.occupied(i)) {
				continue;
			}
			if (!is_simple && partial != b.partial(i)) {
				continue;
			}
			if (key_eq()(b.key(i), key)) {
				bool ret = fn((mapped_type)b.val(i));
				val = b.val(i);
				return ret;
			}
		}
		return false;
	}

	// cuckoo_find_fn searches the table for the given key and value, storing the
	// value in the val if it finds the key. It expects the locks to be taken
	// and released outside the function.
	template <typename K, typename Checker>
	cuckoo_status cuckoo_find_fn(const K &key, mapped_type& val, Checker fn,
		const size_t hv, const size_t i1,
		const size_t i2) {
		const partial_t partial = partial_key(hv);
		if (try_read_from_bucket_fn(partial, key, val, fn, buckets_[i1])) {
			return ok;
		}
		if (try_read_from_bucket_fn(partial, key, val, fn, buckets_[i2])) {
			return ok;
		}
		return failure_key_not_found;
	}

	//! find_fn searches through the table for \p key, and stores the associated
	//! value it finds in \p val. must be copy assignable.
	// If the found value also pass the Checker, it returns true, else it returns false.

	template <typename K, typename Checker>
	typename std::enable_if<
		std::is_convertible<Checker, checker_type>::value,
		bool>::type find_fn(const K& key, mapped_type& val, Checker fn) {
		size_t hv = hashed_key(key);
		auto b = snapshot_and_lock_two(hv);
		const cuckoo_status st = cuckoo_find_fn(key, val, fn, hv, b.i[0], b.i[1]);

		return (st == ok);
	}

	// Level 2: good enough

	//! upsert_fn is a combination of update_fn and insert. It first tries updating
	//! the value associated with \p key using \p fn. If \p key is not in the
	//! table, then it runs an insert with \p key and \p val. It will always
	//! succeed, since if the update fails and the insert finds the key already
	//! inserted, it can retry the update.
	// Compared to upsert, upsert_fn can delay the creating value until really needed

	template <typename Updater, typename K, typename Getter>
	typename std::enable_if<
		std::is_convertible<Updater, updater_type>::value,
		void>::type upsert_fn(K&& key, Updater fn, Getter gt) {
		size_t hv = hashed_key(key);
		cuckoo_status st;
		do {
			auto b = snapshot_and_lock_two(hv);
			size_t hp = get_hashpower();
			st = cuckoo_update_fn(key, fn, hv, b.i[0], b.i[1]);
			if (st == ok) {
				break;
			}

			// We run an insert, since the update failed. Since we already have
			// the locks, we don't run cuckoo_insert_loop immediately, to avoid
			// releasing and re-grabbing the locks. Recall, that the locks will
			// be released at the end of this call to cuckoo_insert.
			st = cuckoo_insert(hv, std::move(b), std::forward<K>(key),
				gt());
			if (st == failure_table_full) {
				cuckoo_fast_double(hp);
				// Retry until the insert doesn't fail due to expansion.
				if (cuckoo_insert_loop(hv, std::forward<K>(key), gt())) {
					break;
				}
				// The only valid reason for failure is a duplicate key. In this
				// case, we retry the entire upsert_fn operation.
			}
		} while (st != ok);
	}

	//! find_or_insert searches through the table for \p key, and stores the associated
	//! value it finds in \p val. must be copy assignable.
	// If not found, insert instead and return the inserted value.

	template <typename K, typename... Args>
	bool find_or_insert(const K& key, mapped_type& val, Args&&... newval) {
		size_t hv = hashed_key(key);

		do {
			auto b = snapshot_and_lock_two(hv);
			auto b = snapshot_and_lock_two(hv);
			const cuckoo_status st = cuckoo_find(key, val, hv, b.i[0], b.i[1]);

			if (st != ok)
			{
				st = cuckoo_insert(hv, std::move(b), std::forward<K>(key),
					std::forward<Args>(newval)...);
				if (st == failure_table_full) {
					cuckoo_fast_double(hp);
					// Retry until the insert doesn't fail due to expansion.
					if (cuckoo_insert_loop(hv, std::forward<K>(key),
						std::forward<Args>(newval)...)) {
						break;
					}
					// The only valid reason for failure is a duplicate key. In this
					// case, we retry the entire upsert operation.
				}

				//Then find again. This is not an efficient method, but an easy one.
				hv = hashed_key(key);
				b = snapshot_and_lock_two(hv);
				st = cuckoo_find(key, val, hv, b.i[0], b.i[1]);

				return (st == ok);
			}
		} while (st != ok);

		return (st == ok);
	}


	//! find_or_insert_fn searches through the table for \p key, and stores the associated
	//! value it finds in \p val. must be copy assignable.
	// If the found value also pass the Checker, it returns true, else it returns false.

	template <typename K, typename Checker, typename Getter>
	typename std::enable_if<
		std::is_convertible<Checker, checker_type>::value
		&& std::is_convertible<Getter, getter_type>::value,
		bool>::type find_or_insert_fn(const K& key, mapped_type& val, Checker fn, Getter gt) {
		size_t hv = hashed_key(key);
		auto b = snapshot_and_lock_two(hv);
		const cuckoo_status st = cuckoo_find_fn(key, val, fn, hv, b.i[0], b.i[1]);

		if (st != ok)
		{
			val = (mapped_type)gt();
			st = cuckoo_insert(hv, std::move(b), std::forward<K>(key), val);
		}
		return (st == ok);
	}

	//	Level 3: Flexible Combinations, Not needed so far
	//		such as Find_or_Delete, update_find

	//! update_find searches through the table for \p key, and stores the associated
	//! value it finds in \p val. must be copy assignable.
	// If the found value also pass the updater, it returns true, else it returns false.

	template <typename K, typename Updater>
	typename std::enable_if<
		std::is_convertible<Updater, updater_type>::value,
		bool>::type update_find(const K& key, mapped_type& val, Updater fn) {
		size_t hv = hashed_key(key);
		auto b = snapshot_and_lock_two(hv);
		const cuckoo_status st = cuckoo_update_fn(key, fn, hv, b.i[0], b.i[1]);

		if (st == ok)
		{
			const cuckoo_status st2 = cuckoo_find(key, val, hv, b.i[0], b.i[1]);

			return (st2 == ok);
		}
		else
			return false;
	}

	//! find_or_delete_fn searches through the table for \p key, and stores the associated
	//! value it finds in \p val. must be copy assignable.
	// If the found value also pass the checker, it returns true, 
	//else the pair will be deleted and returns false.

	template <typename K, typename Checker>
	typename std::enable_if<
		std::is_convertible<Checker, checker_type>::value,
		bool>::type find_or_delete_fn(const K& key, mapped_type& val, Checker fn) {
		size_t hv = hashed_key(key);
		auto b = snapshot_and_lock_two(hv);
		const cuckoo_status st = cuckoo_find(key, val, hv, b.i[0], b.i[1]);

		if (st == ok)
		{
			bool ret = fn(val);

			if (!ret)
			{
				cuckoo_delete(key, hv, b.i[0], b.i[1]);
				return false;
			}
			else
				return true;
		}
		else
			return false;
	}


	// Level 4========================================= Not easy, Not now
	// nolock_delete makes cuckoo_delete public
	//template <class K>
	//cuckoo_status nolock_delete(const K &key, const size_t hv,
	//	const size_t i1, const size_t i2)
	//{
	//	cuckoo_delete(key, hv, i1, i2);
	//}

	//// nolock_insert makes cuckoo_insert public
	//template <typename K, typename... Args>
	//cuckoo_status nolock_insert(const size_t hv, TwoBuckets b,
	//	K&& key, Args&&... val) {
	//	cuckoo_insert(hv, b, key, val);
	//}

	//// nolock_update makes cuckoo_update public
	//template <typename K, typename V>
	//cuckoo_status nolock_update(const size_t hv, const size_t i1,
	//	const size_t i2, const K &key, V&& val) {
	//	cuckoo_update(hv, i1, i2, key, val);
	//}

	//template <typename K, typename V>
	//typedef void (cuckoohash_map::*nolock_update_ptr_type)(const size_t hv, const size_t i1,
	//	const size_t i2, const K &key, V&& val);

	//const nolock_update_ptr_type nolock_update_ptr = &cuckoohash_map::*nolock_update;
	//
